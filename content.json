{"meta":{"title":"Hexo","subtitle":"","description":"","author":"欲上青天揽月","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Effective Java笔记第四章：类和接口","slug":"类和接口","date":"2020-07-30T01:25:52.000Z","updated":"2020-07-31T07:05:46.925Z","comments":true,"path":"2020/07/30/类和接口/","link":"","permalink":"http://yoursite.com/2020/07/30/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"使类和成员的可访问性最小化区分一个组件设计的好与不好，唯一重要的因素在于，它对于外部的其他组件而言，是否隐藏了其内部数据和其他实现细节。这一概念被称为信息隐藏或者封装，信息隐藏之所以重要是因为：它可以有效地解除组成系统的各个组件之间的耦合关系，即解耦，使得这些组件可以独立地开发测试。规则也非常简单：尽可能使每个类或者成员不被外界访问。对于顶层的类和接口，只有两种访问级别：包私有和公有。如果你用public修饰，那它就是公有的，否则就是包级私有的。如果把它做成公有的，你就有责任永远支持它，否则包级私有在以后的版本，可以对它修改、替换、删除。设计公有API时，可能应该把其他成员都变为私有的，事实上，只有当同一个包内的另一个类真正需要访问一个成员时，才应该删除private修饰符。私有成员和包级私有成员都是一个类实现的部分，一般不会影响导出API，实现Serializable接口除外。另外一个注意：受保护的成员时类导出API的一部分，必须永远得到支持，应该尽量少用受保护的成员。公有类的实例域决不能是公有的，同时，包含公有可变域的类通常不是线程安全的。静态域的情况也适用：假设常量构成了类提供的整个抽象的一部分，可以通过公有的静态final来暴露这些常量。重要的一点是，这些域要么包含基本类型的值，要么包含不可变对象的引用。如果final域包含可变对象的引用，它便具有非final的所有缺点。虽然引用本身不能修改，但是它所引用的对象却可以修改，这会导致灾难性后果。举例说明：public class Period { private final Date start; private final Date end;//final修饰的可变对象 private final String str;//final修饰的不可变对象 public Period(Date start, Date end, String str) { this.start = start; this.end = end; this.str = str; } public static void main(String[] args) { Date start = new Date(); Date end = new Date(); String s = &quot;hello&quot;; Period p = new Period(start,end,s); System.out.println(p.start + &quot;时间 &quot; + p.end + &quot;描述&quot; + p.str); end.setYear(1);//仍旧可以修改 System.out.println(p.start + &quot;时间 &quot; + p.end + &quot;描述&quot; + p.str); }} 注意：长度非零的数组总是可变的，所以让类具有公有的静态final数组域，或者返回这种域的访问方式，这是错误的。如果类具有这样的域或者访问方法，客户端将能够修改数组中的内容。这是安全漏洞的一个常见根源：public static final final Thing[] VALUES = {…}。修正方法有两种修正方法：private static final final Thing[] PRIVATE_VALUES = {...} public static final List&lt;Thing&gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES)) private static final Thing[] PRIVATE_VALUES = {...} public static final Thing[] values() { return PRIVATE_VALUES.clone(); }总结：应该始终尽可能降低程序元素的可访问性。除了公有静态final域的特殊情景外（此时它们充当常量），公有类都不应该包含共有域，并且确保公有静态fianl所引用的对象都是不可变的。在公有类而非公有域中使用访问方法说到公有类的时候，如果类可以在它所在的包外进行访问，就提供访问方法。如果类是包级私有的，或者私有的嵌套类，直接暴露它的数据域并没有本质的错误。总而言之，公有类永远都不应该暴露可变的域。使可变性最小定义：不可变类是指其实例不能被修改的类，每个实例中包含的信息都必须在创建该实例的时候就提供，并在对象整个生命周期内固定不变为了使类成为不可变类，应遵循下面五条规则1.不要提供任何会修改对象状态的方法（也称为设值方法）2.保证类不会被扩展3.声明所有的域都是final的4.声明所有的域都为私有的5.确保对于任何可变组件的互斥访问优点：1.不可变对象比较简单；2.不可变对象本质上是线程安全的，它不要求同步，不可变对象可以被自由地共享，甚至也可以共享它们的内部信息；3.不可变对象为其他对象提供大量构建；4.不可变对象无偿地提供了失败的原子性。缺点：对于每个不同的值都需要一个单独的对象（创建这些对象的代价可能很高，特别是大型对象）为了确保不可变性，类绝对不允许自身被子类化。除了“使类成为final的”这种方法外，还有一种方法是让类的所有构造器都变为私有的或者包级私有的，并添加公有的静态工厂来代替公有的构造器。实例：public class Complex{ private final double re; private final double im; private Complex(double re,double im){ this.re = re; this.im = im; } public static Complex valueOf(double re,double im){ return new Complex(re,im); } }总结：总之，坚决不要为每一个get方法编写一个相应的set方法。除非有很好的理由要让类成为可变的类，否则它就应该是不可变的。如果类不能被做成不可变的，仍然应该尽可能地限制它的可变性。除非有令人信服的理由要使域变成非final的，否则要使每一个域都是private final的。构造器应该创建完全初始化的对象，并建立起所有的约束关系。复合优先于继承继承是实现代码重用的有力手段，但它并非永远是完成这项工作的最佳工具。对于普通的具体类进行跨越包边界的继承，则是非常危险的。与方法不同，继承打破了封装性。即：子类依赖超类中特定功能的实现细节。具体缺点参看《Effective Java》P71-P72。解决办法即不扩展现有的类，而是在新的类中增加一个私有域，它引用现有类的一个实例（复合），新类中的每个实例方法都可以调用被包含的现有类实例中对应的方法，并返回它的结果。实例：public class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; { private final Set&lt;E&gt; s; public ForwardingSet(Set&lt;E&gt; s) { this.s = s; } //省略覆盖方法 } public class InstrumentedSet&lt;E&gt; extends ForwardingSet { private int addCount = 0; public InstrumentedSet(Set s) { super(s); } @Override public boolean add(Object o) { addCount++; return super.add(o); } @Override public boolean addAll(@NotNull Collection c) { addCount += c.size(); return super.addAll(c); } public int getAddCount() { return addCount; } }这种设计除了获得健壮性外，还带来极大的灵活性。这里的包装类可以被用来包装任何Set实现，并且可以结合任何先前存在的构造器一起工作。因为每一个InstrumentedSet实例都把另一个Set实例包装起来，所以InstrumentedSet类被称为包装类。例如：Set&lt;Instant&gt; times = new InstrumentedSet&lt;&gt;(new TreeSet&lt;&gt;(cmp)) Set&lt;E&gt; s = new InstrumentedSet&lt;&gt;(new hashSet&lt;&gt;(INIY_CAPAC))要么设计继承并提供文档说明，要么禁止继承对于专门为了继承设计并且具有良好文档说明的类而言，首先该类的文档必须精确地描述覆盖每一个方法所带来的影响。也就是说，该类必须有文档说明它可覆盖的方法的自用性。对于每一个公有的或者受保护的方法或者构造器，它的文档必须指明该方法或者构造器调用了那些方法，是以什么顺序调用的，调用结果又是如何影响后序处理过程的。对于为了继承设计的类，唯一的测试方法就是编写子类，必须在发布类之前编写子类对类进行测试。为了允许继承，类还要遵守一些其他规则。构造器决不能调用可覆盖的方法，无论直接调用还是间接调用。注意：通过构造器调用私有的、final的、静态的方法都是安全的，这些都是不可覆盖的。接口优于抽象类接口的优势：1.现有的类可以很容易被更新，以实现新的接口，而一般来说，无法更新现有的类老扩展新的抽象类；2.接口是定义mixin(混合类型)的理想选择；3.接口允许构造非层次结构的类型框架；4.通过包装类模式，接口使得安全地增强类的功能成为可能；4.骨架实现类。为后代设计接口接口只用于定义类型当类实现接口的时候，接口就充当可以引用这个类的实例的类型。因此，类实现接口就表明客户端可以对这个类的实例实施某些动作。为了任何其他目的而定义接口是不恰当的。常量接口模式是对接口的不良使用。实现常量接口会导致把这样的实现细节泄漏到该类的导出API中例如public interface PhysicalConstants { static final double AVOGADROS_NUMBER = 6.022_140_857e23; static final double BOLTZMANM_CONSTANT = 1.380_648_52e23; }总之，接口应该只被用来定义类型，它们不应该被用来导出常量类层次优于标签类标签类：public class Figure_Demo { enum Shape {RECTANGLE,CIRCLE}; final Shape shape; double length; double width; double radius; public Figure_Demo(double radius) { shape = Shape.CIRCLE; this.radius = radius; } public Figure_Demo(double length,double width) { shape = Shape.RECTANGLE; this.width = width; this.length = length; } double area() { switch (shape){ case RECTANGLE: return length * width; case CIRCLE: return Math.PI * (radius * radius); default: throw new AssertionError(shape); } } }标签类有许多缺点，充斥着样板代码，过于冗长、容易出错，并且效率低下。幸运的是，面向对象语言提供了其他更好的方法来定义能够表示多种风格对象的单个数据类型：子类化。标签类正是对类层次的一种简单效仿。为了将标签类转变为类层次，首先要为标签类中的每个方法都定义一个抽象方法的抽象类，标签类的行为依赖于标签值。在Figure_Demo类中，只有一个方法：area。这个抽象类是类层次的根。如果还有其他方法其行为不依赖于标签的值，就把这样的方法放在这个类中。同样地，如果所有的方法都用到了某些数据域，就应该把它们放在这个类中。在Figure_Demo类中，并不存在这种类型独立的方法或者数据域。类层次：abstract class Figure { abstract double area();}class Circle extends Figure{ final double radius; public Circle(double radius) { this.radius = radius; } @Override double area() { return Math.PI * (radius * radius); }}class Rectangle extends Figure{ final double length; final double width; public Rectangle(double length, double width) { this.length = length; this.width = width; } @Override double area() {// Circle circle = new Circle(5);// System.out.println(circle.radius); return length * width; }} 静态成员类优于非静态成员类静态成员类可以访问外围类的所有成员，包括那些声明为私有的成员。静态成员是外围类的一个静态成员，与其他静态成员一样，遵守同样的可访问性规则。非静态成员类的每一个实例都隐含地与外围类的一个外围实例相关联。在非静态成员类的实例方法内部，可以调用外围实例的方法，或者利用修饰过得this构造获取外围实例的引用。如果嵌套类的实例可以在它外围类的实例之外独立存在，这个嵌套类就必须是静态成员类：在没有外围实例的情况下，要想创建非静态成员类的实例是不可能的。当非静态成员类的实例被创建后，它和外围实例之间的关系已经确定，并且不能被修改。举例public class inner_Class_Test { int a = 1; private final int b = 5; static int c = 5; void hello() { System.out.println(&quot;hello world!!!&quot;); } private static class inner{ static void print() { //System.out.println(a);//不能访问非静态变量 } static void sum(int a, int b) { System.out.println(a+b); } void hello(int a, int b) { System.out.println(a+b); } } private class in{ static void visit()//非静态成员不能包含静态方法，编译不通过。 { System.out.println(c); } void hello_() { hello(); } } public static void main(String[] args) { inner_Class_Test.inner inner = new inner(); inner_Class_Test outer = new inner_Class_Test(); inner_Class_Test.inner.sum(outer.a,outer.b); inner.hello(outer.a,outer.b); inner_Class_Test.inner.print(); }} 总而言之，如果成员类的每一个实例都需要一个指向其外围实例的引用，就把成员类做成非静态的；否则就是静态的。限制源文件为单个顶级类。《Effective Java》第四章笔记","categories":[],"tags":[]},{"title":"创建和销毁对象","slug":"创建和销毁对象","date":"2020-07-11T07:34:53.000Z","updated":"2020-07-12T09:14:36.862Z","comments":true,"path":"2020/07/11/创建和销毁对象/","link":"","permalink":"http://yoursite.com/2020/07/11/%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"创建和销毁对象1.遇到多个构造器函数参数时要考虑使用构建器包含多个参数的构造器public NutritionFact(int servings, int servingSize, int calories, String name, String address...) { this.servings = servings; this.servingSize = servingSize; this.calories = calories; this.name = name; this.address = address; ... }当我们遇到这种情况时，可选的第二种情况就是编写大量的修改器方法，即：Set()方法。不过遗憾的是因为构造被分为几个调用中，在构造过程中可能出现不一致的状态，调试起来非常麻烦第三种方法即时书中的建造者模式的一种形式。它并不直接生成想要的对象，而是让客户端在builder的对象上调用类似的setter方法，来设置相关的可选参数。最后客户端调用无参的builder方法来生成通常是不可变的对象。这个builder通常是它构建的静态成员类。下面是书中示例：public class Builder_Demo { private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; public static class Builder{ private final int servingSize; private final int servings; private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public Builder(int servingSize, int servings) { this.servingSize = servingSize; this.servings = servings; } public Builder calories(int val) { calories = val; return this;//返回Builder自身，Chapter_two.Builder_Demo$Builder@1540e19d } public Builder fat(int val) { fat = val; return this;//返回Builder自身，Chapter_two.Builder_Demo$Builder@1540e19d } public Builder sodium(int val) { sodium = val; return this;//返回Builder自身，Chapter_two.Builder_Demo$Builder@1540e19d } public Builder carbohydrate(int val) { carbohydrate = val; return this;//返回Builder自身，Chapter_two.Builder_Demo$Builder@1540e19d } public Builder_Demo build() { return new Builder_Demo(this);//返回Builder自身，Chapter_two.Builder_Demo$Builder@1540e19d } } private Builder_Demo(Builder builder) { servingSize = builder.servingSize; servings = builder.servings; calories = builder.calories; fat = builder.fat; sodium = builder.sodium; carbohydrate = builder.carbohydrate; } public static void main(String[] args) { Builder_Demo builder_demo = new Builder_Demo .Builder(240,8) .calories(100).sodium(35).carbohydrate(40).build(); } }优点：十分灵活，可以利用单个builder构建多个对象。builder的参数可以在调用builder方法来创建对象期间进行调整，也可以随着不同的对象而改变。缺点：在十分注重性能的情况下，增加不必要的开销。同时也比重叠构造器更加冗长，因此只在有很多参数的时候才使用它，比如4个极其以上。2.用私有构造器或者枚举类型强化Singleton属性实现单例有两种常见方法。首先都是要保持构造器私有化，并导出公有静态成员。public class singletonDemo{ private static singletonDemo singleton = new singletonDemo();//1. public static singletonDemo getSingleton(){return singleton} private singletonDemo(){...} public static singletonDemo singleton = new singletonDemo();//2. }书中所提倡的是使用枚举方法来实现singleton。它有许多优点。首先它非常简单，其次不需要担心序列化的问题，在者它是线程安全的。示例：public enum singletonDemo{ INSTANCE； }注意，如果Singleton必须扩展一个超类，而不是扩展Enum时，则不适宜用这种方式。3.通过私有构造器强化不可实例化的能力企图通过将类做成抽象类来强制该类不可被实例化是行不通的，该类可以被子类化，而子类可以被实例化。同时也会误导用户以为这种类是专门为了继承我而设计的。我们可以通过让类包含一个私有构造器，它就不能被实例化了。缺点是该类也不能被子类化了。4.优先考虑依赖注入来引用资源有许多类会依赖一个或者多个底层资源。静态工具类和Singleton类并不适合需要引用底层资源的类。我们需要的是能够支持类的多个实例，每个实例都使用客户端指定的资源。满足需求的最简单的模式就是，当创建一个新的实例的时候，就将该资源传到构造器中。这就是依赖注入的一种形式：词典是拼写检查器的一个依赖，在创建拼写检查器的时候将词典注入其中。public class SpellChecker{ private final Lexicon dictionary; public SpellChecker(Lexicon dictionary){ this.dictionary = Object.requireNonNull(dictionary)//检查参数是否为null } }依赖注入适用于任意数量的资源，以及任意的依赖形式。依赖注入的对象资源具有不可变性，多个客户端可以共享依赖对象，依赖注入也同样适用于构造器、静态工厂和构建器。5.避免创建不必要的对象一般来说我们最好重用单个对象，而不是在每次需要的时候就创建一个相同功能的新对象。我们来看一个反例String s = new String(&quot;bike&quot;)，我们完全可以用String s = “bike”代替，它可以保证对于所有在同一台虚拟机上运行的代码，只要他们包含相同的字符串字面量，该对象就可以被重用。对于同时提供静态工厂方法和构造器的不可变类，通常优先使用静态工厂方法而不是构造器，来避免创建不必要的对象。有些对象创建的成本很高，我们如果重复需要这类昂贵的对象，建议缓存下来重用。示例：public class RomanNumerals{ private static final Pattern ROMAN = Pattern.compile(//显式将正则表达式编译成一个Pattern实例（不可变），让它成为类初始化的一部分(而非出发类初始化)，并将其缓存起来，每当调用isRomanNumberals就重用同一个实例 &quot;^(?=.)M * (C[MD]|D?{0,3})&quot; +&quot;(x[cL]|L?x{0,3})(I[XV]|V?I(0,3)$&quot;); static boolean isRomanNumberals(String s) { return ROMAN.matcher(s).matches() } ) }改进后的isRomanNumberals方法如果被频繁调用，会显示出明显的性能提升。另外一种创建多余对象的方法，称作自动装箱。我们要优先使用基本类型而不是装箱基本类型，当心无意识的自动装箱。例如：private static long sum(){ Long sum = 0L;//变量被声明为Long而不是long，意味着程序构造了大约2^31个多余的Long实例。 for(long i = 0; i &lt; Integer.MAX_VALUE; i++) sum += i; return sum }6.消除过期的对象引用java的自动回收机制并不是我们不再需要考虑内存管理的事情。栈实现例子：public class Stack{ private Object[] elements; private int Size = 0; private Static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(){...}//入栈 public Object pop(){ if(size == 0) throw new EmptyStackException(); return elemnts[--size] }//出栈 private void ensureCapacity(){...}//扩容 }在这个程序中，如果一个栈先是增长，然后再收缩，那么，从栈中弹出的对象将不会被当做垃圾回收，即使使用栈的程序不再引用这些对象，他们也不会被回收，因为栈内部维护着这些对象的过期引用。一旦对象引用过期，只需清空即可，对于上述实例，只需在一个元素被pop后，指向它的引用就过期了。修改只需在返回之前，添加一条将引用指向null，elemnts[size]=null。如果一个对象引用被无意识地保留下来，那么垃圾回收机制不仅不会处理这个对象，而且也不会处理被这个对象所引用的所有其他对象，从而对性能造成潜在的重大影响。同时清空过期引用的另外一个好处是，如果它们以后又错误地被引用，程序就会立即抛出NullPointerException异常。注意：一般来说，只要类是自己管理内存，程序员就应该警惕内存泄漏的问题，一旦元素被释放掉，则该元素中包含的任何对象引用都应该清空。内存泄漏的另一个常见来源是缓存。内存泄漏的第三个常见来源是监听器和其他回调。7.避免使用终结方法和清除方法终结方法通常是不可预测的，也是很危险的，一般情况下是不必要的。清除方法没有终结方法那么危险，但仍然是不可预测、运行缓慢，一般情况下也是没有必要的。二者的缺点在于不能保证会被及时执行，一个对象从不可到达开始到它的终结方法被执行，所花费的时间是任意长的。这意味着注重时间的的任务不应该由终结方法或者清除方法来完成，甚至Java语言规范根本不保证它们会执行。我们永远不应该依赖终结方法或者清除方法来更新重要的持久状态。8.try-with-resources优于try-finallyJava类库中包括许多必须通过调用close方法来收工关闭资源，比如I/O中,数据库连接中等等，我们以前常用的模式是try-finally，在finally中去关闭资源。示例：static void copy(String src, String dst){ InputStream in = new FileInputStream(src); try{ OutputStream out = new FileOutputStream(dst); try{ byte[] buf = new byte[BUFFER_SIZE] ; int n; while((n = in.read(buf)) &gt; 0) out.write(buf,0,n); }finally{ out.close(); } }finally{ in.close(); } }因为try块和finally块都会抛出异常，在某些情况下，第二个异常完全抹除第一个异常。在异常堆栈里，完全没没有关于第一个异常的记录，这会使得在现实的系统中调试非常复杂。在java7以后引用的try-with-resources语句解决了全部问题。要使用这个构造的资源，必须先实现AutoCloseable接口，其中包含了单个返回的void的close方法。如果我们编写一个类，它代表的是必须要被关闭的资源，那么这个类应该实现AutoCloseable接口。上述示例改为try-with-resources语模式static void copy(String src, String dst){ try(InputStream in = new FileInputStream(src);OutputStream out = new FileOutputStream(dst)){ byte[] buf = new byte[BUFFER_SIZE] ; int n; while((n = in.read(buf)) &gt; 0) out.write(buf,0,n); } }结论；在处理必须关闭的资源时，始终要优先考虑try-with-resources模式，而不是try-finally模式。","categories":[],"tags":[]},{"title":"对象通用方法","slug":"对象通用方法","date":"2020-06-27T02:12:07.000Z","updated":"2020-06-28T02:17:56.552Z","comments":true,"path":"2020/06/27/对象通用方法/","link":"","permalink":"http://yoursite.com/2020/06/27/%E5%AF%B9%E8%B1%A1%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"覆盖equals时请遵守约定覆盖equals方法看似简单，但是许多覆盖会导致错误，并非任何时刻都需要覆盖满足一下情况时不需要覆盖1.类的每个实例本质上是唯一的。我自身理解就是使用的类不需要或者不包含值的类，比如线程类，仅仅只包含线程对象，比较时只需要比较线程对象，而不用在覆盖equals方法去比较其他的数据2.类没有必要提供“逻辑相等”的测试功能3.父类已经覆盖equals方法，并且父类的行为对于这个类也是合适的实例中Person父类覆盖了equals方法，子类Player的需求和父类相同只是比较年龄和身高，所以父类的equals方法子类直接沿用，不需要再覆盖 控制台分别返回false,true类是私有的，或者包是私有的，可以确定equals方法永远不会被调用而如果类具有自己特有的“逻辑相等”，并且父类并没有覆盖equals方法，我们应该考虑覆盖equals方法。书中所说这种类通常属于值类，我的理解是包含值的类并且进行比较，比较其逻辑相等，而非引用同一个对象。比如基本类型，String类型在覆盖equals方法时，我们必须遵守equals方法的约定1.自反性，即：非空引用值X，X.eqauls(X)，必须返回true2.对错性，非空前提下，y.equals（x）,x.equals(y)结果返回必须一样3.传递性，即x.equals(y)为true，y.equals(z)为true,则x.equlas(z)也必须为true不建议采用getClass()，应使用instanceof代替getClass()4.一致性，非空引用x、y,只要equals在对象中所用的信息没有被修改，多次调用equals一致必须返回true不要使equals依赖于不可靠的资源5.非空性，任何非空引用x,x.equals(null)必须返回false在测试非空时，我们可以在使用instanceof测试时检测非空，没必要在if(o==null)在传递扩展这方面存在一个基本问题：我们无法在扩展可实例化的类的同时，既增加新的值组件，同时还保留equals约定。 对于这种问题的解决办法，我们可以编写一个不相关的；类，其中包含第一个类的实例。然后提供一个视图方法返回这个实例 告诫覆盖equlas时总要覆盖hashCode不要企图让equals更智能不要将equals声明中的Object对象替换为其他类型覆盖hashCode方法注意点每个覆盖equlas方法必须覆盖hashCode方法Objects类有静态方法，方法名hash，效果很好，但是运行速度慢一些不要试图从散列码计算中排除掉一个对象的关键域来提高性能始终覆盖toString方法注意无论是否指定格式，都为toString返回值中包含的所有信息提供一种可以通过编程访问的途径。例如get和set方法在静态工具类中编写toString方法是没有意义的，也不要在大多数枚举类型中编写toString方法，因为java已经提供了非常完美的方法在所有其子类共享通用字符串表示法的抽象类中，一定要编写一个toString方法考虑实现Comparable接口参考点1.在编写值类的时候，具有非常明显的内在排序关系，考虑实现Comparable接口2.满足对错性（equals类似)3.传递性4.书中强烈建议（x.compareTo(y) == 0) == (x.equals(y))。一般来说，任何实现了Comparable接口的类，若违反了这个条件，都应该说明：注意，该类具有内在的排序功能，但是与equals不一致说明comparaTo不能跨越不同类型的对象进行比较，在比较是可以抛出异常在comparaTo中同样存在equals的“无法在用新的值组件扩展课实例化的类时，同时保持comparaTo约定。解决方式也和equals类似在第四条参考点中，通常情况下应该返回与equals方法相同的情况，但也会出现不同的情况比如在java.math.BigDecimal ，其自然排序等于BigDecimal具有相同值和不同精度（例如4.0和4.00）的对象。此时equals不相等，而comparaTo相等。导致在存入集合时，hashSet会存入4.0和4.00，而TreeSet只会存一个comparaTo不必进行类型检查，如果不是同类型的对象进行比较只需要抛出错误comparaTo中的域（值）比较是顺序比较，而不是同等性比较，简单来说就是分主次比较，先比较最重要的，若结果不相等直接返回结果，不再进行下面域的比较，若相等则再进行次重要的数据比较，以此类推不要在comparaTo中使用大于和小于，直接使用静态方法，比如Double.compare等比较器构造方法","categories":[],"tags":[]},{"title":"静态工厂方法代替构造器","slug":"静态工厂方法代替构造器","date":"2020-06-12T07:03:56.000Z","updated":"2020-06-17T08:17:55.306Z","comments":true,"path":"2020/06/12/静态工厂方法代替构造器/","link":"","permalink":"http://yoursite.com/2020/06/12/%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E5%99%A8/","excerpt":"","text":"用静态工厂方法代替构造器优势：1.静态工厂方法有名称valueOf： 该方法返回的实例与参数具有相同的值，实际是类型转换方法；of： valueOf的一种替代，在EnumSet使用并流行起来；getInstance：返回的实例是通过参数进行描述的，不能说与参数具有相同的值，对于Singleton单例模式来说，没有参数，返回唯一的实例；newInstance：返回的实例是一个新的实例，与之前返回的都不相同；getType：与getInstance一样，但是在工厂方法处于不同的类时候使用，Type表示工厂方法所返回的对象类型；newType： 与newInstance一样，但是在工厂方法处于不同的类时候使用，Type表示工厂方法所返回的对象类型。2.用静态工厂方法代替构造器，不必在每次调用的时候都创建一个新对象。从而可以有效避免不必要的重复对象，更加高效。静态工厂方法：private static Node instance = null;public static Node getInstance(){if (instance == null)instance = new Node();return instance;}带参方法public static Node getInstance(int data){if (instance == null)instance = new Node(data);return instance;}构造函数省略可以返回原返回类型的任何子类型的对象public static Father newInstance(String type) {if (type.equals(“ChildA”)) { // 根据类型判断返回那个子类对象return new ChildA();} else {return new ChildB();}}3.所返回的对象的类可以随着每次调用而发生改变，取决于静态工厂方法的参数值，同上带参方法4.方法返回的对象所属的类在编写该静态方法时可以不存在。缺点：类如果不含有公有的或者受保护的构造器，就不能被子类化（继承）静态工厂经常更加合适，因此切忌第一反应就是提供公有的构造器，而不是优先考虑静态工厂","categories":[],"tags":[]}],"categories":[],"tags":[]}