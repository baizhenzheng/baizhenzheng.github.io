{"meta":{"title":"Hexo","subtitle":"","description":"","author":"欲上青天揽月","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"创建和销毁对象","slug":"创建和销毁对象","date":"2020-07-11T07:34:53.000Z","updated":"2020-07-12T09:14:36.862Z","comments":true,"path":"2020/07/11/创建和销毁对象/","link":"","permalink":"http://yoursite.com/2020/07/11/%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"创建和销毁对象1.遇到多个构造器函数参数时要考虑使用构建器包含多个参数的构造器public NutritionFact(int servings, int servingSize, int calories, String name, String address...) { this.servings = servings; this.servingSize = servingSize; this.calories = calories; this.name = name; this.address = address; ... }当我们遇到这种情况时，可选的第二种情况就是编写大量的修改器方法，即：Set()方法。不过遗憾的是因为构造被分为几个调用中，在构造过程中可能出现不一致的状态，调试起来非常麻烦第三种方法即时书中的建造者模式的一种形式。它并不直接生成想要的对象，而是让客户端在builder的对象上调用类似的setter方法，来设置相关的可选参数。最后客户端调用无参的builder方法来生成通常是不可变的对象。这个builder通常是它构建的静态成员类。下面是书中示例：public class Builder_Demo { private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; public static class Builder{ private final int servingSize; private final int servings; private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public Builder(int servingSize, int servings) { this.servingSize = servingSize; this.servings = servings; } public Builder calories(int val) { calories = val; return this;//返回Builder自身，Chapter_two.Builder_Demo$Builder@1540e19d } public Builder fat(int val) { fat = val; return this;//返回Builder自身，Chapter_two.Builder_Demo$Builder@1540e19d } public Builder sodium(int val) { sodium = val; return this;//返回Builder自身，Chapter_two.Builder_Demo$Builder@1540e19d } public Builder carbohydrate(int val) { carbohydrate = val; return this;//返回Builder自身，Chapter_two.Builder_Demo$Builder@1540e19d } public Builder_Demo build() { return new Builder_Demo(this);//返回Builder自身，Chapter_two.Builder_Demo$Builder@1540e19d } } private Builder_Demo(Builder builder) { servingSize = builder.servingSize; servings = builder.servings; calories = builder.calories; fat = builder.fat; sodium = builder.sodium; carbohydrate = builder.carbohydrate; } public static void main(String[] args) { Builder_Demo builder_demo = new Builder_Demo .Builder(240,8) .calories(100).sodium(35).carbohydrate(40).build(); } }优点：十分灵活，可以利用单个builder构建多个对象。builder的参数可以在调用builder方法来创建对象期间进行调整，也可以随着不同的对象而改变。缺点：在十分注重性能的情况下，增加不必要的开销。同时也比重叠构造器更加冗长，因此只在有很多参数的时候才使用它，比如4个极其以上。2.用私有构造器或者枚举类型强化Singleton属性实现单例有两种常见方法。首先都是要保持构造器私有化，并导出公有静态成员。public class singletonDemo{ private static singletonDemo singleton = new singletonDemo();//1. public static singletonDemo getSingleton(){return singleton} private singletonDemo(){...} public static singletonDemo singleton = new singletonDemo();//2. }书中所提倡的是使用枚举方法来实现singleton。它有许多优点。首先它非常简单，其次不需要担心序列化的问题，在者它是线程安全的。示例：public enum singletonDemo{ INSTANCE； }注意，如果Singleton必须扩展一个超类，而不是扩展Enum时，则不适宜用这种方式。3.通过私有构造器强化不可实例化的能力企图通过将类做成抽象类来强制该类不可被实例化是行不通的，该类可以被子类化，而子类可以被实例化。同时也会误导用户以为这种类是专门为了继承我而设计的。我们可以通过让类包含一个私有构造器，它就不能被实例化了。缺点是该类也不能被子类化了。4.优先考虑依赖注入来引用资源有许多类会依赖一个或者多个底层资源。静态工具类和Singleton类并不适合需要引用底层资源的类。我们需要的是能够支持类的多个实例，每个实例都使用客户端指定的资源。满足需求的最简单的模式就是，当创建一个新的实例的时候，就将该资源传到构造器中。这就是依赖注入的一种形式：词典是拼写检查器的一个依赖，在创建拼写检查器的时候将词典注入其中。public class SpellChecker{ private final Lexicon dictionary; public SpellChecker(Lexicon dictionary){ this.dictionary = Object.requireNonNull(dictionary)//检查参数是否为null } }依赖注入适用于任意数量的资源，以及任意的依赖形式。依赖注入的对象资源具有不可变性，多个客户端可以共享依赖对象，依赖注入也同样适用于构造器、静态工厂和构建器。5.避免创建不必要的对象一般来说我们最好重用单个对象，而不是在每次需要的时候就创建一个相同功能的新对象。我们来看一个反例String s = new String(&quot;bike&quot;)，我们完全可以用String s = “bike”代替，它可以保证对于所有在同一台虚拟机上运行的代码，只要他们包含相同的字符串字面量，该对象就可以被重用。对于同时提供静态工厂方法和构造器的不可变类，通常优先使用静态工厂方法而不是构造器，来避免创建不必要的对象。有些对象创建的成本很高，我们如果重复需要这类昂贵的对象，建议缓存下来重用。示例：public class RomanNumerals{ private static final Pattern ROMAN = Pattern.compile(//显式将正则表达式编译成一个Pattern实例（不可变），让它成为类初始化的一部分(而非出发类初始化)，并将其缓存起来，每当调用isRomanNumberals就重用同一个实例 &quot;^(?=.)M * (C[MD]|D?{0,3})&quot; +&quot;(x[cL]|L?x{0,3})(I[XV]|V?I(0,3)$&quot;); static boolean isRomanNumberals(String s) { return ROMAN.matcher(s).matches() } ) }改进后的isRomanNumberals方法如果被频繁调用，会显示出明显的性能提升。另外一种创建多余对象的方法，称作自动装箱。我们要优先使用基本类型而不是装箱基本类型，当心无意识的自动装箱。例如：private static long sum(){ Long sum = 0L;//变量被声明为Long而不是long，意味着程序构造了大约2^31个多余的Long实例。 for(long i = 0; i &lt; Integer.MAX_VALUE; i++) sum += i; return sum }6.消除过期的对象引用java的自动回收机制并不是我们不再需要考虑内存管理的事情。栈实现例子：public class Stack{ private Object[] elements; private int Size = 0; private Static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(){...}//入栈 public Object pop(){ if(size == 0) throw new EmptyStackException(); return elemnts[--size] }//出栈 private void ensureCapacity(){...}//扩容 }在这个程序中，如果一个栈先是增长，然后再收缩，那么，从栈中弹出的对象将不会被当做垃圾回收，即使使用栈的程序不再引用这些对象，他们也不会被回收，因为栈内部维护着这些对象的过期引用。一旦对象引用过期，只需清空即可，对于上述实例，只需在一个元素被pop后，指向它的引用就过期了。修改只需在返回之前，添加一条将引用指向null，elemnts[size]=null。如果一个对象引用被无意识地保留下来，那么垃圾回收机制不仅不会处理这个对象，而且也不会处理被这个对象所引用的所有其他对象，从而对性能造成潜在的重大影响。同时清空过期引用的另外一个好处是，如果它们以后又错误地被引用，程序就会立即抛出NullPointerException异常。注意：一般来说，只要类是自己管理内存，程序员就应该警惕内存泄漏的问题，一旦元素被释放掉，则该元素中包含的任何对象引用都应该清空。内存泄漏的另一个常见来源是缓存。内存泄漏的第三个常见来源是监听器和其他回调。7.避免使用终结方法和清除方法终结方法通常是不可预测的，也是很危险的，一般情况下是不必要的。清除方法没有终结方法那么危险，但仍然是不可预测、运行缓慢，一般情况下也是没有必要的。二者的缺点在于不能保证会被及时执行，一个对象从不可到达开始到它的终结方法被执行，所花费的时间是任意长的。这意味着注重时间的的任务不应该由终结方法或者清除方法来完成，甚至Java语言规范根本不保证它们会执行。我们永远不应该依赖终结方法或者清除方法来更新重要的持久状态。8.try-with-resources优于try-finallyJava类库中包括许多必须通过调用close方法来收工关闭资源，比如I/O中,数据库连接中等等，我们以前常用的模式是try-finally，在finally中去关闭资源。示例：static void copy(String src, String dst){ InputStream in = new FileInputStream(src); try{ OutputStream out = new FileOutputStream(dst); try{ byte[] buf = new byte[BUFFER_SIZE] ; int n; while((n = in.read(buf)) &gt; 0) out.write(buf,0,n); }finally{ out.close(); } }finally{ in.close(); } }因为try块和finally块都会抛出异常，在某些情况下，第二个异常完全抹除第一个异常。在异常堆栈里，完全没没有关于第一个异常的记录，这会使得在现实的系统中调试非常复杂。在java7以后引用的try-with-resources语句解决了全部问题。要使用这个构造的资源，必须先实现AutoCloseable接口，其中包含了单个返回的void的close方法。如果我们编写一个类，它代表的是必须要被关闭的资源，那么这个类应该实现AutoCloseable接口。上述示例改为try-with-resources语模式static void copy(String src, String dst){ try(InputStream in = new FileInputStream(src);OutputStream out = new FileOutputStream(dst)){ byte[] buf = new byte[BUFFER_SIZE] ; int n; while((n = in.read(buf)) &gt; 0) out.write(buf,0,n); } }结论；在处理必须关闭的资源时，始终要优先考虑try-with-resources模式，而不是try-finally模式。","categories":[],"tags":[]},{"title":"对象通用方法","slug":"对象通用方法","date":"2020-06-27T02:12:07.000Z","updated":"2020-06-28T02:17:56.552Z","comments":true,"path":"2020/06/27/对象通用方法/","link":"","permalink":"http://yoursite.com/2020/06/27/%E5%AF%B9%E8%B1%A1%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"覆盖equals时请遵守约定覆盖equals方法看似简单，但是许多覆盖会导致错误，并非任何时刻都需要覆盖满足一下情况时不需要覆盖1.类的每个实例本质上是唯一的。我自身理解就是使用的类不需要或者不包含值的类，比如线程类，仅仅只包含线程对象，比较时只需要比较线程对象，而不用在覆盖equals方法去比较其他的数据2.类没有必要提供“逻辑相等”的测试功能3.父类已经覆盖equals方法，并且父类的行为对于这个类也是合适的实例中Person父类覆盖了equals方法，子类Player的需求和父类相同只是比较年龄和身高，所以父类的equals方法子类直接沿用，不需要再覆盖 控制台分别返回false,true类是私有的，或者包是私有的，可以确定equals方法永远不会被调用而如果类具有自己特有的“逻辑相等”，并且父类并没有覆盖equals方法，我们应该考虑覆盖equals方法。书中所说这种类通常属于值类，我的理解是包含值的类并且进行比较，比较其逻辑相等，而非引用同一个对象。比如基本类型，String类型在覆盖equals方法时，我们必须遵守equals方法的约定1.自反性，即：非空引用值X，X.eqauls(X)，必须返回true2.对错性，非空前提下，y.equals（x）,x.equals(y)结果返回必须一样3.传递性，即x.equals(y)为true，y.equals(z)为true,则x.equlas(z)也必须为true不建议采用getClass()，应使用instanceof代替getClass()4.一致性，非空引用x、y,只要equals在对象中所用的信息没有被修改，多次调用equals一致必须返回true不要使equals依赖于不可靠的资源5.非空性，任何非空引用x,x.equals(null)必须返回false在测试非空时，我们可以在使用instanceof测试时检测非空，没必要在if(o==null)在传递扩展这方面存在一个基本问题：我们无法在扩展可实例化的类的同时，既增加新的值组件，同时还保留equals约定。 对于这种问题的解决办法，我们可以编写一个不相关的；类，其中包含第一个类的实例。然后提供一个视图方法返回这个实例 告诫覆盖equlas时总要覆盖hashCode不要企图让equals更智能不要将equals声明中的Object对象替换为其他类型覆盖hashCode方法注意点每个覆盖equlas方法必须覆盖hashCode方法Objects类有静态方法，方法名hash，效果很好，但是运行速度慢一些不要试图从散列码计算中排除掉一个对象的关键域来提高性能始终覆盖toString方法注意无论是否指定格式，都为toString返回值中包含的所有信息提供一种可以通过编程访问的途径。例如get和set方法在静态工具类中编写toString方法是没有意义的，也不要在大多数枚举类型中编写toString方法，因为java已经提供了非常完美的方法在所有其子类共享通用字符串表示法的抽象类中，一定要编写一个toString方法考虑实现Comparable接口参考点1.在编写值类的时候，具有非常明显的内在排序关系，考虑实现Comparable接口2.满足对错性（equals类似)3.传递性4.书中强烈建议（x.compareTo(y) == 0) == (x.equals(y))。一般来说，任何实现了Comparable接口的类，若违反了这个条件，都应该说明：注意，该类具有内在的排序功能，但是与equals不一致说明comparaTo不能跨越不同类型的对象进行比较，在比较是可以抛出异常在comparaTo中同样存在equals的“无法在用新的值组件扩展课实例化的类时，同时保持comparaTo约定。解决方式也和equals类似在第四条参考点中，通常情况下应该返回与equals方法相同的情况，但也会出现不同的情况比如在java.math.BigDecimal ，其自然排序等于BigDecimal具有相同值和不同精度（例如4.0和4.00）的对象。此时equals不相等，而comparaTo相等。导致在存入集合时，hashSet会存入4.0和4.00，而TreeSet只会存一个comparaTo不必进行类型检查，如果不是同类型的对象进行比较只需要抛出错误comparaTo中的域（值）比较是顺序比较，而不是同等性比较，简单来说就是分主次比较，先比较最重要的，若结果不相等直接返回结果，不再进行下面域的比较，若相等则再进行次重要的数据比较，以此类推不要在comparaTo中使用大于和小于，直接使用静态方法，比如Double.compare等比较器构造方法","categories":[],"tags":[]},{"title":"静态工厂方法代替构造器","slug":"静态工厂方法代替构造器","date":"2020-06-12T07:03:56.000Z","updated":"2020-06-17T08:17:55.306Z","comments":true,"path":"2020/06/12/静态工厂方法代替构造器/","link":"","permalink":"http://yoursite.com/2020/06/12/%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E5%99%A8/","excerpt":"","text":"用静态工厂方法代替构造器优势：1.静态工厂方法有名称valueOf： 该方法返回的实例与参数具有相同的值，实际是类型转换方法；of： valueOf的一种替代，在EnumSet使用并流行起来；getInstance：返回的实例是通过参数进行描述的，不能说与参数具有相同的值，对于Singleton单例模式来说，没有参数，返回唯一的实例；newInstance：返回的实例是一个新的实例，与之前返回的都不相同；getType：与getInstance一样，但是在工厂方法处于不同的类时候使用，Type表示工厂方法所返回的对象类型；newType： 与newInstance一样，但是在工厂方法处于不同的类时候使用，Type表示工厂方法所返回的对象类型。2.用静态工厂方法代替构造器，不必在每次调用的时候都创建一个新对象。从而可以有效避免不必要的重复对象，更加高效。静态工厂方法：private static Node instance = null;public static Node getInstance(){if (instance == null)instance = new Node();return instance;}带参方法public static Node getInstance(int data){if (instance == null)instance = new Node(data);return instance;}构造函数省略可以返回原返回类型的任何子类型的对象public static Father newInstance(String type) {if (type.equals(“ChildA”)) { // 根据类型判断返回那个子类对象return new ChildA();} else {return new ChildB();}}3.所返回的对象的类可以随着每次调用而发生改变，取决于静态工厂方法的参数值，同上带参方法4.方法返回的对象所属的类在编写该静态方法时可以不存在。缺点：类如果不含有公有的或者受保护的构造器，就不能被子类化（继承）静态工厂经常更加合适，因此切忌第一反应就是提供公有的构造器，而不是优先考虑静态工厂","categories":[],"tags":[]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2020-05-31T17:32:48.000Z","updated":"2020-06-02T14:15:07.524Z","comments":true,"path":"2020/06/01/我的第一篇博客文章/","link":"","permalink":"http://yoursite.com/2020/06/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"第一章内容 第二章内容 参考文献www.baidu.com","categories":[],"tags":[]}],"categories":[],"tags":[]}