{"meta":{"title":"Hexo","subtitle":"","description":"","author":"欲上青天揽月","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"静态工厂方法代替构造器","slug":"静态工厂方法代替构造器","date":"2020-06-12T07:03:56.000Z","updated":"2020-06-12T08:42:01.182Z","comments":true,"path":"2020/06/12/静态工厂方法代替构造器/","link":"","permalink":"http://yoursite.com/2020/06/12/%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E5%99%A8/","excerpt":"","text":"用静态工厂方法代替构造器优势：1.静态工厂方法有名称valueOf： 该方法返回的实例与参数具有相同的值，实际是类型转换方法；of： valueOf的一种替代，在EnumSet使用并流行起来；getInstance：返回的实例是通过参数进行描述的，不能说与参数具有相同的值，对于Singleton单例模式来说，没有参数，返回唯一的实例；newInstance：返回的实例是一个新的实例，与之前返回的都不相同；getType：与getInstance一样，但是在工厂方法处于不同的类时候使用，Type表示工厂方法所返回的对象类型；newType： 与newInstance一样，但是在工厂方法处于不同的类时候使用，Type表示工厂方法所返回的对象类型。2.用静态工厂方法代替构造器，不必在每次调用的时候都创建一个新对象。从而可以有效避免不必要的重复对象，更加高效。静态工厂方法：private static Node instance = null;public static Node getInstance(){if (instance == null)instance = new Node();return instance;}带参方法public static Node getInstance(int data){if (instance == null)instance = new Node();return instance;}构造函数省略可以返回原返回类型的任何子类型的对象public static Father newInstance(String type) {if (type.equals(“ChildA”)) { // 根据类型判断返回那个子类对象return new ChildA();} else {return new ChildB();}}3.所返回的对象的类可以随着每次调用而发生改变，取决于静态工厂方法的参数值，同上带参方法4.方法返回的对象所属的类在编写该静态方法时可以不存在。缺点：类如果不含有公有的或者受保护的构造器，就不能被子类化（继承）静态工厂经常更加合适，因此切忌第一反应就是提供公有的构造器，而不是优先考虑静态工厂","categories":[],"tags":[]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2020-05-31T17:32:48.000Z","updated":"2020-06-02T14:15:07.524Z","comments":true,"path":"2020/06/01/我的第一篇博客文章/","link":"","permalink":"http://yoursite.com/2020/06/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"第一章内容 第二章内容 参考文献www.baidu.com","categories":[],"tags":[]}],"categories":[],"tags":[]}