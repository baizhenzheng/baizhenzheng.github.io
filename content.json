{"meta":{"title":"Hexo","subtitle":"","description":"","author":"欲上青天揽月","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"对象通用方法","slug":"对象通用方法","date":"2020-06-27T02:12:07.000Z","updated":"2020-06-27T09:49:05.641Z","comments":true,"path":"2020/06/27/对象通用方法/","link":"","permalink":"http://yoursite.com/2020/06/27/%E5%AF%B9%E8%B1%A1%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"覆盖equals时请遵守约定覆盖equals方法看似简单，但是许多覆盖会导致错误，并非任何时刻都需要覆盖满足一下情况时不需要覆盖1.类的每个实例本质上是唯一的。我自身理解就是使用的类不需要或者不包含值的类，比如线程类，仅仅只包含线程对象，比较时只需要比较线程对象，而不用在覆盖equals方法去比较其他的数据2.类没有必要提供“逻辑相等”的测试功能3.父类已经覆盖equals方法，并且父类的行为对于这个类也是合适的实例中Person父类覆盖了equals方法，子类Player的需求和父类相同只是比较年龄和身高，所以父类的equals方法子类直接沿用，不需要再覆盖 控制台分别返回false,true类是私有的，或者包是私有的，可以确定equals方法永远不会被调用而如果类具有自己特有的“逻辑相等”，并且父类并没有覆盖equals方法，我们应该考虑覆盖equals方法。书中所说这种类通常属于值类，我的理解是包含值的类并且进行比较，比较其逻辑相等，而非引用同一个对象。比如基本类型，String类型在覆盖equals方法时，我们必须遵守equals方法的约定1.自反性，即：非空引用值X，X.eqauls(X)，必须返回true2.对错性，非空前提下，y.equals（x）,x.equals(y)结果返回必须一样3.传递性，即x.equals(y)为true，y.equals(z)为true,则x.equlas(z)也必须为true建议采用getClass()，应使用instanceof代替getClass()4.一致性，非空引用x、y,只要equals在对象中所用的信息没有被修改，多次调用equals一致必须返回true不要使equals依赖于不可靠的资源5.非空性，任何非空引用x,x.equals(null)必须返回false在测试非空时，我们可以在使用instanceof测试时检测非空，没必要在if(o==null)在传递扩展这方面存在一个基本问题：我们无法在扩展可实例化的类的同时，既增加新的值组件，同时还保留equals约定。 对于这种问题的解决办法，我们可以编写一个不相关的；类，其中包含第一个类的实例。然后提供一个视图方法返回这个实例 告诫覆盖equlas时总要覆盖hashCode不要企图让equals更智能不要将equals声明中的Object对象替换为其他类型覆盖hashCode方法注意点每个覆盖equlas方法必须覆盖hashCode方法Objects类有静态方法，方法名hash，效果很好，但是运行速度慢一些不要试图从散列码计算中排除掉一个对象的关键域来提高性能始终覆盖toString方法注意无论是否指定格式，都为toString返回值中包含的所有信息提供一种可以通过编程访问的途径。例如get和set方法在静态工具类中编写toString方法是没有意义的，也不要在大多数枚举类型中编写toString方法，因为java已经提供了非常完美的方法在所有其子类共享通用字符串表示法的抽象类中，一定要编写一个toString方法考虑实现Comparable接口参考点1.在编写值类的时候，具有非常明显的内在排序关系，考虑实现Comparable接口2.满足对错性（equals类似)3.传递性4.书中强烈建议（x.compareTo(y) == 0) == (x.equals(y))。一般来说，任何实现了Comparable接口的类，若违反了这个条件，都应该说明：注意，该类具有内在的排序功能，但是与equals不一致说明comparaTo不能跨越不同类型的对象进行比较，在比较是可以抛出异常在comparaTo中同样存在equals的“无法在用新的值组件扩展课实例化的类时，同时保持comparaTo约定。解决方式也和equals类似在第四条参考点中，通常情况下应该返回与equals方法相同的情况，但也会出现不同的情况比如在java.math.BigDecimal ，其自然排序等于BigDecimal具有相同值和不同精度（例如4.0和4.00）的对象。此时equals不相等，而comparaTo相等。导致在存入集合时，hashSet会存入4.0和4.00，而TreeSet只会存一个comparaTo不必进行类型检查，如果不是同类型的对象进行比较只需要抛出错误comparaTo中的域（值）比较是顺序比较，而不是同等性比较，简单来说就是分主次比较，先比较最重要的，若结果不相等直接返回结果，不再进行下面域的比较，若相等则再进行次重要的数据比较，以此类推不要在comparaTo中使用大于和小于，直接使用静态方法，比如Double.compare等比较器构造方法","categories":[],"tags":[]},{"title":"静态工厂方法代替构造器","slug":"静态工厂方法代替构造器","date":"2020-06-12T07:03:56.000Z","updated":"2020-06-17T08:17:55.306Z","comments":true,"path":"2020/06/12/静态工厂方法代替构造器/","link":"","permalink":"http://yoursite.com/2020/06/12/%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E5%99%A8/","excerpt":"","text":"用静态工厂方法代替构造器优势：1.静态工厂方法有名称valueOf： 该方法返回的实例与参数具有相同的值，实际是类型转换方法；of： valueOf的一种替代，在EnumSet使用并流行起来；getInstance：返回的实例是通过参数进行描述的，不能说与参数具有相同的值，对于Singleton单例模式来说，没有参数，返回唯一的实例；newInstance：返回的实例是一个新的实例，与之前返回的都不相同；getType：与getInstance一样，但是在工厂方法处于不同的类时候使用，Type表示工厂方法所返回的对象类型；newType： 与newInstance一样，但是在工厂方法处于不同的类时候使用，Type表示工厂方法所返回的对象类型。2.用静态工厂方法代替构造器，不必在每次调用的时候都创建一个新对象。从而可以有效避免不必要的重复对象，更加高效。静态工厂方法：private static Node instance = null;public static Node getInstance(){if (instance == null)instance = new Node();return instance;}带参方法public static Node getInstance(int data){if (instance == null)instance = new Node(data);return instance;}构造函数省略可以返回原返回类型的任何子类型的对象public static Father newInstance(String type) {if (type.equals(“ChildA”)) { // 根据类型判断返回那个子类对象return new ChildA();} else {return new ChildB();}}3.所返回的对象的类可以随着每次调用而发生改变，取决于静态工厂方法的参数值，同上带参方法4.方法返回的对象所属的类在编写该静态方法时可以不存在。缺点：类如果不含有公有的或者受保护的构造器，就不能被子类化（继承）静态工厂经常更加合适，因此切忌第一反应就是提供公有的构造器，而不是优先考虑静态工厂","categories":[],"tags":[]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2020-05-31T17:32:48.000Z","updated":"2020-06-02T14:15:07.524Z","comments":true,"path":"2020/06/01/我的第一篇博客文章/","link":"","permalink":"http://yoursite.com/2020/06/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"第一章内容 第二章内容 参考文献www.baidu.com","categories":[],"tags":[]}],"categories":[],"tags":[]}